# Security Considerations

## OAuth 2.0 & OIDC

### Cross-Site Request Forgery (CSRF)

CSRF is an attack that forces an end user to execute unwanted actions on a web application in which they're currently authenticated. With a little help of social engineering (such as sending a link via email or chat), an attacker may trick the users of a web application into executing actions of the attacker's choosing.

In a typical CSRF attack, the victim is logged into a legitimate site (e.g., their bank). The attacker tricks the victim into visiting a malicious site or clicking a link that sends a request to the legitimate site (e.g., `POST /transfer-funds`). Since the victim's browser automatically includes their session cookies, the legitimate site thinks the victim intended to make the request.

### State Parameter (CSRF Protection in OAuth)

The `state` parameter in the OAuth 2.0 authorization request is a critical security mechanism used to prevent Cross-Site Request Forgery (CSRF) attacks.

**Why it is needed (The "Login CSRF" Attack):**
Without a `state` parameter, an attacker can trick a victim into logging into the attacker's account.

*Example Scenario:*
1.  **Attacker** starts the login flow on `sortedchat.com` using their own Google account.
2.  When Google redirects back to the application with an authorization code (e.g., `https://sortedchat.com/callback?code=ATTACKER_CODE&state=ATTACKER_STATE`), the attacker **stops** the browser from loading this URL and copies it.
    *   Note: The URL includes `state=ATTACKER_STATE`, which matches the cookie in the **Attacker's** browser.
3.  The attacker sends this link to the **Victim** via email or chat.
4.  The **Victim** clicks the link.
5.  `sortedchat.com` receives the request with `ATTACKER_CODE`. Since there is no state check, the server accepts it, exchanges the code, and logs the browser session in.
6.  **Result:** The Victim is now logged in as the **Attacker**.
7.  The Victim, thinking they are in their own account, enters sensitive information (e.g., credit card details, private messages).
8.  The Attacker logs into their account later and sees all the data the Victim entered.

The `state` parameter prevents this because the Victim's browser won't have the cookie that matches the `state` generated by the Attacker's session.

**How it works:**
1.  **Generation**: When the application initiates the OAuth flow (redirects the user to the provider), it generates a cryptographically random string (the `state`).
2.  **Storage**: This `state` is stored on the client-side (e.g., in a secure, HTTP-only cookie) or in a server-side session bound to the user's browser.
3.  **Transmission**: The `state` is passed as a query parameter in the authorization URL.
4.  **Verification**: When the provider redirects the user back to the application's callback URL, it includes the same `state` parameter. The application must verify that the returned `state` matches the stored `state`.

**Implementation:**
- The `BuildLoginURL` method accepts a `state` string.
- The API handler is responsible for generating a random state and verifying it upon callback.
- **Do not use a hardcoded or static string** (like "state") in production, as this completely nullifies the protection.
